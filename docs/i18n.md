# Internationalisation Workflow

This project maintains a single source of truth for all user-facing copy in the
`src/greektax/translations` directory. Each locale is described by a JSON file
named after its [BCP 47 language tag](https://www.rfc-editor.org/rfc/bcp/bcp47.txt)
(e.g. `en.json`, `el.json`). The catalogues are consumed by both the Flask API
and the static front-end so that all surfaces display identical translations.

## Translation Catalogue Structure

```text
src/greektax/translations/
├── en.json  # English strings
└── el.json  # Greek strings
```

Each file is a flat JSON object where the keys match the identifiers used by the
application. The keys are shared across locales and must remain consistent so
that copy updates stay aligned.

Example excerpt:

```json
{
  "landing.title": "GreekTax calculator",
  "landing.subtitle": "Estimate your annual tax obligations"
}
```

Keys can be nested logically using dot notation. The translator automatically
falls back to the `en` catalogue whenever a requested key or locale is missing.

## Adding or Updating Strings

1. Edit the relevant catalogue(s) under `src/greektax/translations/`.
   - Update both `en.json` and `el.json` when introducing a new key so the
     locales remain synchronised.
   - Keep the files alphabetically sorted to minimise merge conflicts.
2. Regenerate the embedded bundle that ships with the static front-end:

   ```bash
   python scripts/embed_translations.py
   ```

   The script reads the JSON catalogues and outputs
   `src/frontend/assets/scripts/translations.generated.js`. Commit this file so
   production builds stay in sync.
3. Run the automated checks to confirm the catalogues and bundle still match the
   expectations enforced by the test suite:

   ```bash
   pytest
   ```

4. Commit the updated JSON files, generated bundle, and any accompanying tests
   or documentation.

## Adding a New Language

1. Create a new JSON catalogue named after the locale tag, for example
   `src/greektax/translations/fr.json`.
2. Populate the file by copying the keys from `en.json` and translating the
   values. Every key present in the default catalogue must exist in the new
   file.
3. Regenerate the front-end bundle so the new locale is embedded:

   ```bash
   python scripts/embed_translations.py
   ```

4. If the locale should be selectable in the UI, add the language option to the
   locale picker in `src/frontend/assets/scripts/main.js`. The option's value
   must match the new locale tag.
5. Run the tests to verify fallbacks and bundle integrity:

   ```bash
   pytest
   ```

6. Commit the new catalogue, generated bundle, and any UI updates.

## Verifying API Responses

The `/api/v1/translations` endpoint serves the same catalogue data consumed by
the front-end. After any catalogue change, you can manually verify the API
payload by running the Flask app and issuing a request:

```bash
flask --app greektax.backend.app run
curl http://localhost:5000/api/v1/translations?locale=el
```

The response should contain the translated strings you just added or modified.

## Common Pitfalls

- **Missing keys**: if you forget to add a key to every locale, the back-end will
  fall back to English. Automated tests will also fail, highlighting the missing
  entry.
- **Uncommitted bundle**: the static UI relies on the generated bundle. Always
  regenerate and commit `translations.generated.js` after editing the catalogues.
- **Locale tag mismatch**: ensure the locale picker values, JSON filenames, and
  API requests use the same locale identifier to avoid unexpected fallbacks.

Following this process keeps translations aligned across the stack and minimises
manual synchronisation effort.
